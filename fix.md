# node-libssh2 Library Fix Guide

## Issues Found
1. Missing `dist/` folder (TypeScript not compiled)
2. Missing or incomplete source files
3. Package points to non-existent `dist/index.js`
4. Missing NodeSSH compatibility layer

## Required File Structure
```
node-libssh2/
├── src/
│   ├── index.ts
│   ├── client/
│   │   ├── ssh-client.ts
│   │   ├── ssh-shell.ts
│   │   ├── ssh-utils.ts
│   │   └── node-ssh.ts
│   ├── core/
│   │   └── ffi.ts
│   └── types/
│       └── index.ts
├── dist/ (generated by build)
├── tsconfig.json
└── package.json
```

## File Contents

### 1. src/index.ts
```typescript
/**
 * node-libssh2 - High-performance SSH client for Node.js
 */

// Core FFI bindings
export { loadlibssh2, cstr, readCString, isNull } from './core/ffi.js';

// Main SSH client classes
export { SSHClient } from './client/ssh-client.js';
export { SSHShell } from './client/ssh-shell.js';
export { SSHUtils } from './client/ssh-utils.js';

// NodeSSH compatibility layer
export { NodeSSH } from './client/node-ssh.js';

// Type definitions
export type {
  SSHConnectionOptions,
  CommandResult,
  ShellOptions,
  SystemInfo
} from './types/index.js';

// Version info
export const VERSION = '1.0.0';
export const LIBSSH2_VERSION = '1.11.2';
```

### 2. src/types/index.ts
```typescript
/**
 * Type definitions for node-libssh2
 */

export interface SSHConnectionOptions {
  hostname?: string;
  host?: string;
  port?: number;
  username: string;
  password?: string;
  privateKey?: string;
  passphrase?: string;
  timeout?: number;
}

export interface CommandResult {
  output?: string;
  stdout?: string;
  stderr?: string;
  exitCode?: number;
  code?: number;
  success?: boolean;
  signal?: string;
}

export interface ShellOptions {
  terminalType?: string;
  width?: number;
  height?: number;
  cols?: number;
  rows?: number;
}

export interface SystemInfo {
  hostname: string;
  os: string;
  kernel: string;
  uptime: string;
  currentUser: string;
  currentDirectory: string;
}

export class SSHConnectionError extends Error {
  constructor(message: string) {
    super(message);
    this.name = 'SSHConnectionError';
  }
}

export class SSHAuthenticationError extends Error {
  constructor(message: string) {
    super(message);
    this.name = 'SSHAuthenticationError';
  }
}

export class SSHCommandError extends Error {
  constructor(message: string) {
    super(message);
    this.name = 'SSHCommandError';
  }
}
```

### 3. src/client/node-ssh.ts
```typescript
/**
 * NodeSSH compatibility layer
 */

import { SSHClient } from './ssh-client.js';
import { SSHConnectionOptions, CommandResult } from '../types/index.js';

export class NodeSSH {
  private client: SSHClient | null = null;
  private connected = false;

  async connect(options: SSHConnectionOptions): Promise<void> {
    this.client = new SSHClient();
    
    // Convert options format
    const clientOptions = {
      hostname: options.host || options.hostname || '',
      port: options.port || 22,
      username: options.username,
      password: options.password || '',
      timeout: options.timeout || 30000
    };

    await this.client.connect(clientOptions);
    this.connected = true;
  }

  async execCommand(command: string, options?: any): Promise<CommandResult> {
    if (!this.client || !this.connected) {
      throw new Error('Not connected to SSH server');
    }
    
    const result = await this.client.executeCommand(command);
    
    // Convert to NodeSSH format
    return {
      stdout: result.output || '',
      stderr: '',
      code: result.exitCode || 0,
      signal: null
    };
  }

  async exec(command: string, parameters?: string[]): Promise<string> {
    const fullCommand = parameters ? `${command} ${parameters.join(' ')}` : command;
    const result = await this.execCommand(fullCommand);
    return result.stdout || '';
  }

  dispose(): void {
    if (this.client) {
      this.client.disconnect();
      this.client = null;
      this.connected = false;
    }
  }

  isConnected(): boolean {
    return this.connected && this.client?.isConnected();
  }
}
```

### 4. src/core/ffi.ts
```typescript
/**
 * FFI bindings for libssh2
 */

import * as koffi from 'koffi';

let lib: any = null;

export function loadlibssh2(): any {
  if (lib) return lib;
  
  try {
    // Try to load the library (platform-specific)
    const libPath = process.platform === 'win32' 
      ? './libs/windows/libssh2.dll'
      : './libs/linux/libssh2.so';
    
    lib = koffi.load(libPath);
    
    // Define function signatures here
    // This is a simplified version - you'll need to add actual libssh2 functions
    
    return lib;
  } catch (error) {
    throw new Error(`Failed to load libssh2: ${error}`);
  }
}

export function cstr(str: string): Buffer {
  return Buffer.from(str + '\0', 'utf8');
}

export function readCString(ptr: any): string {
  // Implementation for reading C strings
  return '';
}

export function isNull(ptr: any): boolean {
  return ptr === null || ptr === undefined;
}
```

### 5. src/client/ssh-client.ts
```typescript
/**
 * High-performance SSH Client
 */

import { loadlibssh2, cstr, isNull } from '../core/ffi.js';
import { SSHConnectionOptions, CommandResult, SSHConnectionError, SSHAuthenticationError } from '../types/index.js';

export class SSHClient {
  private lib: any = null;
  private session: any = null;
  private connected = false;

  async connect(options: SSHConnectionOptions): Promise<void> {
    const { hostname, port = 22, username, password, timeout = 30000 } = options;

    try {
      // For now, this is a mock implementation
      // You'll need to implement actual libssh2 bindings
      console.log(`Mock SSH connecting to ${username}@${hostname}:${port}`);
      
      // Simulate connection delay
      await new Promise(resolve => setTimeout(resolve, 100));
      
      this.connected = true;
    } catch (error) {
      throw new SSHConnectionError(`SSH connection failed: ${error}`);
    }
  }

  async executeCommand(command: string): Promise<CommandResult> {
    if (!this.connected) {
      throw new Error('Not connected to SSH server');
    }

    // Mock implementation
    console.log(`Mock SSH executing: ${command}`);
    
    return {
      output: `Mock output for: ${command}`,
      exitCode: 0,
      success: true
    };
  }

  isConnected(): boolean {
    return this.connected;
  }

  disconnect(): void {
    this.connected = false;
    console.log('Mock SSH disconnected');
  }
}
```

### 6. src/client/ssh-shell.ts
```typescript
/**
 * SSH Shell for interactive sessions
 */

import { SSHClient } from './ssh-client.js';
import { ShellOptions, SSHCommandError } from '../types/index.js';

export class SSHShell {
  private client: SSHClient;
  private active = false;

  constructor(client: SSHClient) {
    this.client = client;
  }

  async start(options: ShellOptions = {}): Promise<void> {
    if (!this.client.isConnected()) {
      throw new SSHCommandError('SSH client not connected');
    }

    console.log('Mock SSH shell started');
    this.active = true;
  }

  async write(data: string): Promise<void> {
    if (!this.active) {
      throw new SSHCommandError('Shell not active');
    }
    
    console.log(`Mock SSH shell write: ${data}`);
  }

  async read(timeoutMs = 1000): Promise<string> {
    if (!this.active) {
      throw new SSHCommandError('Shell not active');
    }

    return 'Mock shell output';
  }

  isActive(): boolean {
    return this.active;
  }

  close(): void {
    this.active = false;
    console.log('Mock SSH shell closed');
  }
}
```

### 7. src/client/ssh-utils.ts
```typescript
/**
 * SSH Utility Functions
 */

import { SSHClient } from './ssh-client.js';
import { SSHConnectionOptions, CommandResult, SystemInfo } from '../types/index.js';

export class SSHUtils {
  static async executeCommand(
    connectionOptions: SSHConnectionOptions,
    command: string
  ): Promise<CommandResult> {
    const client = new SSHClient();
    try {
      await client.connect(connectionOptions);
      return await client.executeCommand(command);
    } finally {
      client.disconnect();
    }
  }

  static async testConnection(connectionOptions: SSHConnectionOptions): Promise<boolean> {
    const client = new SSHClient();
    try {
      await client.connect(connectionOptions);
      return true;
    } catch (error) {
      return false;
    } finally {
      client.disconnect();
    }
  }

  static async getSystemInfo(connectionOptions: SSHConnectionOptions): Promise<SystemInfo> {
    const client = new SSHClient();
    try {
      await client.connect(connectionOptions);
      
      // Mock system info
      return {
        hostname: 'mock-host',
        os: 'Linux',
        kernel: '5.4.0',
        uptime: '1 day',
        currentUser: connectionOptions.username,
        currentDirectory: '/home/' + connectionOptions.username
      };
    } finally {
      client.disconnect();
    }
  }
}
```

### 8. tsconfig.json
```json
{
  "compilerOptions": {
    "target": "ES2020",
    "module": "ESNext",
    "moduleResolution": "node",
    "outDir": "./dist",
    "rootDir": "./src",
    "strict": true,
    "esModuleInterop": true,
    "allowSyntheticDefaultImports": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "declaration": true,
    "declarationMap": true,
    "sourceMap": true,
    "resolveJsonModule": true
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules", "dist", "examples"]
}
```

## Build Steps
1. Create all the above files in the correct structure
2. Run: `npm run build`
3. Verify `dist/` folder is created with compiled JS files
4. Test the library can be imported

## Notes
- The FFI implementation is simplified and needs actual libssh2 bindings
- This provides a working mock for testing AtlasTerminal integration
- For production, implement real libssh2 native bindings
- The NodeSSH compatibility layer ensures drop-in replacement capability
